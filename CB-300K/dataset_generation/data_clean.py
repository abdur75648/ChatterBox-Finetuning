import json
import os


import argparse
parser = argparse.ArgumentParser()
parser.add_argument('--relation_file_path',default='/path/to/Visual Genome/relationships.json')
parser.add_argument('--attribute_file_path',default='/path/to/Visual Genome/attributes.json')
parser.add_argument('--img_dir',default='./image_info/exist_image_list.json')#generated by detecting whether image exists
parser.add_argument('--save_dir', default='/path/to/save')
parser.add_argument('--relation_distance_restrict',default=2.2)
parser.add_argument('--simple_nms_thresh',default=0.25)
parser.add_argument('--do_all_nms_thresh',default=0.7)
parser.add_argument('--n',default=499)
args = parser.parse_args()


def get_id_list(file_path):
    with open(file_path,'r') as f:
        return json.load(f)

def py_cpu_nms(dets, thresh):
    x1 = dets[:, 0]
    y1 = dets[:, 1]
    x2 = dets[:, 2]
    y2 = dets[:, 3]
    areas = (y2 - y1 + 1) * (x2 - x1 + 1)
    scores = dets[:, 4]
    keep = []
    index = scores.argsort()[::-1]
    while index.size > 0:
        i = index[0]  # every time the first is the biggst, and add it directly
        keep.append(i)

        x11 = np.maximum(x1[i], x1[index[1:]])  # calculate the points of overlap
        y11 = np.maximum(y1[i], y1[index[1:]])
        x22 = np.minimum(x2[i], x2[index[1:]])
        y22 = np.minimum(y2[i], y2[index[1:]])

        w = np.maximum(0, x22 - x11 + 1)  # the weights of overlap
        h = np.maximum(0, y22 - y11 + 1)  # the height of overlap

        overlaps = w * h
        ious = overlaps / (areas[i] + areas[index[1:]] - overlaps)
        idx = np.where(ious <= thresh)[0]
        index = index[idx + 1]  # because index start from 1
    return keep

import numpy as np


def simple_nms(dets, thresh):
    x1 = dets[:, 0]
    y1 = dets[:, 1]
    x2 = dets[:, 2]
    y2 = dets[:, 3]
    areas = (y2 - y1 + 1) * (x2 - x1 + 1)
    scores = dets[:, 4]
    keep = []
    index = scores.argsort()[::-1]
    pair = []
    while index.size > 0:
        i = index[0]  # every time the first is the biggst, and add it directly
        keep.append(i)

        x11 = np.maximum(x1[i], x1[index[1:]])  # calculate the points of overlap
        y11 = np.maximum(y1[i], y1[index[1:]])
        x22 = np.minimum(x2[i], x2[index[1:]])
        y22 = np.minimum(y2[i], y2[index[1:]])

        w = np.maximum(0, x22 - x11 + 1)  # the weights of overlap
        h = np.maximum(0, y22 - y11 + 1)  # the height of overlap

        overlaps = w * h
        ious = overlaps / (areas[i] + areas[index[1:]] - overlaps)
        idx = np.where(ious <= thresh)[0]
        high_idx = np.where(ious > thresh)[0]
        high_idx = index[high_idx + 1]
        pair.append([i] + list(high_idx))
        index = index[idx + 1]  # because index start from 1

    return keep, pair

def do_all_nms(dets, thresh):
    object_name_bbox = []
    det = []
    keep = []
    if len(dets) > 1:
        for bbox_name in dets:
            object_name_bbox.append(bbox_name)
            det.append(eval(bbox_name.split(":")[0]) + [len(bbox_name.split(":")[1])])
        det = np.array(det)
        keep = py_cpu_nms(det, thresh)
    return keep

def not_same(sub,obj):
    sub=sub.replace(' ','')
    obj=obj.replace(' ','')
    if sub not in obj and obj not in sub:
        return True
    else:
        return False

def process_relationship_v1(line_list):
    line_np=np.array(line_list)
    line_np=np.unique(line_np)
    return line_np.tolist()

#devide relation file into batch for parallel data generation with gpt-4
id_list=get_id_list(args.img_dir)
id_batch=[]

n=args.n
cnt_n=0
a=[]
for cnt,i in enumerate(id_list):
    if cnt_n<n and cnt_n>0:
        cnt_n+=1
        a.append(i)
    elif cnt_n==0:
        cnt_n += 1
        a=[i]
    else:
        cnt_n=0
        a.append(i)
        id_batch.append(a)
id_batch.append(a)

relation_file = open(args.relation_file_path, "r")
relation = json.load(relation_file)
relation_file.close()

attribute_file = open(args.attribute_file_path, "r")
attribute = json.load(attribute_file)
attribute_file.close()

id_caption={}
import json
save_base_dir=os.path.join(args.save_dir,'batch','relation')
if not os.path.exists(save_base_dir):
    os.makedirs(save_base_dir)

#data filter
for i, data in enumerate(relation):
    if data["image_id"] in id_list:
        relationships = data["relationships"]
        object_list = {}
        score = {}
        object_name = []
        for j in relationships:
            box_of_object = [j["object"]["x"], j["object"]["y"],
                             j["object"]["w"] + j["object"]["x"],
                             j["object"]["h"] + j["object"]["y"]]
            box_of_subject = [j["subject"]["x"], j["subject"]["y"],
                              j["subject"]["w"] + j["subject"]["x"],
                              j["subject"]["h"] + j["subject"]["y"]]
            name_of_object = j["object"]["name"] if "name" in j["object"].keys() else j["object"]["names"][0]
            name_of_subject = j["subject"]["name"] if "name" in j["subject"].keys() else j["subject"]["names"][0]

            name_of_object = name_of_object.split(" ")[-1]
            name_of_subject = name_of_subject.split(" ")[-1]

            if str(box_of_object) + ":" + name_of_object not in object_list.keys():
                object_list[str(box_of_object) + ":" + name_of_object] = str(box_of_object) + ":" + name_of_object
                score[str(box_of_object) + ":" + name_of_object] = 1
                object_name.append(name_of_object)
            else:
                score[str(box_of_object) + ":" + name_of_object] += 1
            if str(box_of_subject) + ":" + name_of_subject not in object_list.keys():
                object_list[str(box_of_subject) + ":" + name_of_subject] = str(box_of_subject) + ":" + name_of_subject
                score[str(box_of_subject) + ":" + name_of_subject] = 1
                object_name.append(name_of_subject)
            else:
                score[str(box_of_subject) + ":" + name_of_subject] += 1

        # for objects with same category name and similar coordinates, if iou>simple_nms_thresh, consider them as the same object and change category name to name_index
        object_name = np.unique(object_name)
        for oname in object_name:
            det = []
            det_number = []
            for nms in object_list:
                if object_list[nms].split(":")[1] == oname:
                    det.append(eval(nms.split(":")[0]) + [score[nms]])
                    det_number.append(nms)
            det = np.array(det)
            add_number = 1
            if len(det) > 1:
                keep, pair = simple_nms(det, args.simple_nms_thresh)
                if len(keep) > 1:
                    for add in keep:
                        object_list[det_number[add]] = object_list[det_number[add]] + "_" + str(add_number)
                        add_number += 1
                for change_list in pair:
                    if len(change_list) > 1:
                        for change_number in change_list[1:]:
                            object_list[det_number[change_number]] = object_list[det_number[change_list[0]]]

        all_caption = []
        relation_list = []
        relation_caption_list = []
        attribute_number = []

        for j in relationships:
            judge_object_box = [j["object"]["x"], j["object"]["y"],
                                j["object"]["w"] + j["object"]["x"],
                                j["object"]["h"] + j["object"]["y"]]
            judge_subject_box = [j["subject"]["x"], j["subject"]["y"],
                                 j["subject"]["w"] + j["subject"]["x"],
                                 j["subject"]["h"] + j["subject"]["y"]]
            judge_object_name = j["object"]["name"] if "name" in j["object"].keys() else j["object"]["names"][0]
            judge_subject_name = j["subject"]["name"] if "name" in j["subject"].keys() else j["subject"]["names"][0]

            judge_object_name = judge_object_name.split(" ")[-1]
            judge_subject_name = judge_subject_name.split(" ")[-1]

            # if subject and object are in the same relation and their union area>relation_distance_restrict, remove the relationship
            if str(judge_object_box) + ":" + judge_object_name in object_list.keys() and str(
                    judge_subject_box) + ":" + judge_subject_name in object_list.keys():
                object_box = eval(object_list[str(judge_object_box) + ":" + judge_object_name].split(":")[0])
                subject_box = eval(object_list[str(judge_subject_box) + ":" + judge_subject_name].split(":")[0])
                x11 = np.minimum(object_box[0], subject_box[0])
                x22 = np.maximum(object_box[2], subject_box[2])
                y11 = np.minimum(object_box[1], subject_box[1])
                y22 = np.maximum(object_box[3], subject_box[3])
                area = (object_box[2] - object_box[0]) * (object_box[3] - object_box[1]) + (
                        subject_box[2] - subject_box[0]) * (subject_box[3] - subject_box[1])
                if (((x22 - x11) * (y22 - y11)) / area) <= args.relation_distance_restrict:
                    predicate = j["predicate"]
                    object = object_list[str(judge_object_box) + ":" + judge_object_name].split(":")[1]
                    subject = object_list[str(judge_subject_box) + ":" + judge_subject_name].split(":")[1]
                    object_box = str(object_box)
                    subject_box = str(subject_box)
                    object_caption = ""
                    subject_caption = ""
                    object_attribute = []
                    subject_attribute = []
                    for k, attr in enumerate(attribute):
                        if attr["image_id"] == int(data["image_id"]):
                            attributes = attr["attributes"]
                            for m in attributes:
                                if m["object_id"] == j["object"]["object_id"]:
                                    if "attributes" in m.keys():
                                        if len(m["attributes"]) > 1:
                                            number_attribute = 0
                                            for n in m["attributes"]:
                                                if n not in object:
                                                    object_attribute.append(m["attributes"][number_attribute])
                                                    break
                                                else:
                                                    number_attribute += 1
                                            if number_attribute < len(m["attributes"]) - 1:
                                                for n in m["attributes"][number_attribute + 1:]:
                                                    if n not in object and n not in object_attribute:
                                                        object_attribute.append(n)
                                        else:
                                            object_attribute = [m["attributes"][0]] if m["attributes"][
                                                                                           0] not in object else []
                                if m["object_id"] == j["subject"]["object_id"]:
                                    if "attributes" in m.keys():
                                        if len(m["attributes"]) > 1:
                                            number_attribute = 0
                                            for n in m["attributes"]:
                                                if n not in subject:
                                                    subject_attribute.append(m["attributes"][number_attribute])
                                                    break
                                                else:
                                                    number_attribute += 1
                                            if number_attribute < len(m["attributes"]) - 1:
                                                for n in m["attributes"][number_attribute + 1:]:
                                                    if n not in subject and n not in subject_attribute:
                                                        subject_attribute.append(n)
                                        else:
                                            subject_attribute = [m["attributes"][0]] if m["attributes"][
                                                                                            0] not in object else []

                    tempory_object_attribute = []
                    for iter_id, iter_object_attribute in enumerate(object_attribute):
                        temperory_object = object_attribute[0:iter_id] + object_attribute[iter_id + 1:]
                        state = 0
                        for temperory in temperory_object:
                            state = 1 if iter_object_attribute in temperory else 0
                        if state == 0:
                            tempory_object_attribute.append(iter_object_attribute)
                    object_attribute = tempory_object_attribute
                    tempory_object_attribute = []

                    tempory_subject_attribute = []
                    for iter_id, iter_subject_attribute in enumerate(subject_attribute):
                        temperory_subject = subject_attribute[0:iter_id] + subject_attribute[iter_id + 1:]
                        state = 0
                        for temperory in temperory_subject:
                            state = 1 if iter_subject_attribute in temperory else 0
                        if state == 0:
                            tempory_subject_attribute.append(iter_subject_attribute)
                    subject_attribute = tempory_subject_attribute
                    tempory_subject_attribute = []

                    if len(object_attribute) > 1:
                        object_caption = object_attribute[0]
                        for iter_id, iter_object_attribute in enumerate(object_attribute[1:]):
                            if iter_id < 2:
                                object_caption = object_caption + " " + "and" + " " + iter_object_attribute
                            else:
                                break
                    elif len(object_attribute) == 1:
                        object_caption = object_attribute[0]

                    if len(subject_attribute) > 1:
                        subject_caption = subject_attribute[0]
                        for iter_id, iter_subject_attribute in enumerate(subject_attribute[1:]):
                            if iter_id < 2:
                                subject_caption = subject_caption + " " + "and" + " " + iter_subject_attribute
                            else:
                                break
                    elif len(subject_attribute) == 1:
                        subject_caption = subject_attribute[0]

                    relation_list.append([[object_caption, object, object_box],
                                          [predicate],
                                          [subject_caption, subject, subject_box]])
                    if len(object_caption) > 0:
                        relation_caption_list.append(object_caption + " " + object)
                    else:
                        relation_caption_list.append(object)
                    if len(subject_caption) > 0:
                        relation_caption_list.append(subject_caption + " " + subject)
                    else:
                        relation_caption_list.append(subject)
                    attribute_number.append(len(object_attribute))
                    attribute_number.append(len(subject_attribute))

        for iter_id, iter_relation_caption in enumerate(relation_caption_list):
            temperory_list = relation_caption_list[0:iter_id] + relation_caption_list[iter_id + 1:]
            temperory_attribute_number = attribute_number[iter_id]
            score_caption = 0
            max_score = 0
            for temperory in temperory_list:
                if iter_relation_caption in temperory:
                    if temperory_attribute_number > 0 or iter_relation_caption == temperory.split(" ")[-1]:
                        score_caption = len(temperory)
                        if score_caption > max_score:
                            max_score = score_caption
                            relation_caption_list[iter_id] = temperory

        all_object = []
        for one_object in relation_list:
            if one_object[0][2] + ":" + one_object[0][1] not in all_object:
                all_object.append(one_object[0][2] + ":" + one_object[0][1])
            if one_object[2][2] + ":" + one_object[2][1] not in all_object:
                all_object.append(one_object[2][2] + ":" + one_object[2][1])

        # for objects with similar coordinates, if iou>do_all_nms_thresh, remove
        keep = do_all_nms(all_object, args.do_all_nms_thresh)
        all_object = [all_object[l] for l in keep]

        all_object_copy = []
        for l in all_object:
            bbox = eval(l.split(':')[0])
            if (bbox[2] - bbox[0]) >= 10 and (bbox[3] - bbox[1]) >= 10:
                all_object_copy.append(l)
        all_object = all_object_copy

        all_object_copy = []
        for iter_id, one_object in enumerate(relation_list):
            object_last_box = eval(one_object[0][2])
            subject_last_box = eval(one_object[2][2])

            x11 = max(object_last_box[0], subject_last_box[0])  # calculate the points of overlap
            y11 = max(object_last_box[1], subject_last_box[1])
            x22 = min(object_last_box[2], subject_last_box[2])
            y22 = min(object_last_box[3], subject_last_box[3])

            w = max(0, x22 - x11 + 1)  # the weights of overlap
            h = max(0, y22 - y11 + 1)  # the height of overlap

            overlaps = w * h
            area1 = (object_last_box[2] - object_last_box[0]) * (object_last_box[3] - object_last_box[1])
            area2 = (subject_last_box[2] - subject_last_box[0]) * (subject_last_box[3] - subject_last_box[1])
            ious = overlaps / (area1 + area2 - overlaps)
            caption=''
            if one_object[0][2] + ":" + one_object[0][1] in all_object and \
                    one_object[2][2] + ":" + one_object[2][1] in all_object:
                object = relation_caption_list[2 * iter_id] + one_object[0][2]
                subject = relation_caption_list[2 * iter_id + 1] + one_object[2][2]
                predicate = one_object[1][0]
                if not_same(object,subject):
                    caption = subject + " " + predicate + " " + object
                    caption=caption.lower()
                    all_caption.append(caption)
            elif ious > 0.5:
                object = relation_caption_list[2 * iter_id] + one_object[0][2]
                subject = relation_caption_list[2 * iter_id + 1] + one_object[2][2]
                predicate = one_object[1][0]
                caption = subject + " " + predicate + " " + object
                if not_same(object, subject):
                    caption = subject + " " + predicate + " " + object
                    caption = caption.lower()
                    all_caption.append(caption)
            all_caption=process_relationship_v1(all_caption)
        id_caption[data["image_id"]]=all_caption


for cnt,i in enumerate(id_batch):
    save_dir=os.path.join(save_base_dir,str(cnt))
    if not os.path.exists(save_dir):
        os.makedirs(save_dir)
    for j in i:
        id=j
        caption=id_caption[j]
        with open(os.path.join(save_dir,str(id)+'.json'),'w') as fw:
            json.dump(caption,fw)



